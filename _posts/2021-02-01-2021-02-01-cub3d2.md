---
layout: single
title: "[cub3D] MiniLibX에 대해 알아보자 + 간단한 실습"
categories: "cub3D"
tags: [cub3D, C]
---

42에서 제공하는 MiniLibX는 간단한 윈도우 인터페이스 라이브러리이다.  
인트라의 cub3D 프로젝트 페이지에서 압축파일을 2개 다 다운받을 수 있다.

```
man minilibx_mms_20200219/man/man3/파일이름
```

매뉴얼에 나와있는 함수들을 하나씩 살펴보자.
나는 맥OS로 진행하므로 맥OS 기준으로 작성할 것이다.

# MiniLibX 함수들

## 시작하기

### 1. mlx_init() - 소프트웨어와 디스플레이 연결

```c
 #include <mlx.h>

void    *mlx_init ();
```

MiniLibX로 쉽게 그래픽 소프트웨어를 만들 수 있다. 유닉스/리눅스 체제 하에서 Window/X11 프로그래밍에 대한 지식이나 맥OS에서 AppKit 프로그래밍에 대한 지식 없이도 가능하다. MiniLibX는 간단한 윈도우 생성, 그리기 도구, 이미지 그리고 기본적인 이벤트 관리를 제공한다.

MacOS: 윈도우 서버와 GPU  
소프트웨어는 윈도우 서버와 직접적으로 상호작용한다. 윈도우 서버는 화면 상에서 다른 소프트웨어나 이벤트 시스템과의 공동 생활을 핸들링한다.
소프트웨어는 또 GPU와도 상호작용하여 모든 그리기 도구들을 핸들링하게 된다.

- 가장 먼저, **소프트웨어와 디스플레이 간에 연결을 초기화** 해주어야 한다.
- 연결을 먼저 한 후에 다른 MiniLibX 함수들을 사용해 디스플레이에 메시지를 전송하거나 전송받을 수 있다.  
  예) "이 창(윈도우)에 노란색 픽셀을 그리고 싶어", "유저가 키를 입력했니?"와 같은 메시지들..
- **mlx_init**이 바로 이 연결을 생성하는 함수이다.
- 리턴값: 디스플레이와의 연결 설정에 **실패 시 NULL** 리턴, **성공 시 non-null 포인터**가 **연결 식별자(connection identifier)**로서 리턴된다.

## 창 관리하기

### 1. mlx_new_window() - 새 창을 스크린에 띄우기

```c
void    *mlx_new_window ( void *mlx_ptr, int size_x, int size_y, char *title );
```

- 새 창을 스크린에 띄우는 함수
- size_x, size_y: 창 사이즈(x길이, y길이)
- title: 띄울 창의 타이틀 (창의 타이틀 바에 표시된다)
- mlx_ptr: mlx_init이 반환한 연결 식별자(connection identifier)
- 리턴값: 창 생성 **실패 시 NULL** 리턴, 성공 시 **void \*인 창 식별자** 리턴.

### 2. mlx_clear_window() - 지정된 창을 검은색으로 지우기

```c
int    mlx_clear_window ( void *mlx_ptr, void *win_ptr );
```

- 지정된 창을 검은색으로 지우는 함수
- mlx_ptr: 연결 식별자
- win_ptr: 창 식별자
- 리턴값: 없음

### 3. mlx_destroy_window() - 지정된 창 종료하기

```c
int    mlx_destroy_window ( void *mlx_ptr, void *win_ptr );
```

- 지정된 창을 종료하는 함수
- mlx_ptr: 연결 식별자
- win_ptr: 창 식별자
- 리턴값: 없음

## 이벤트 다루기

그래픽 시스템은 양방향적이다. 한 쪽에서는 프로그램이 스크린에 명령을 보내서 픽셀, 이미지 등을 표시하게 하고, 다른 쪽에서는 스크린에 키보드, 마우스로부터 **이벤트**를 받는다.

### 1. mlx_loop() - 이벤트 받기

```c
int    mlx_loop ( void *mlx_ptr );
```

- **이벤트를 받기 위한 함수.**
- 절대 리턴을 하지 않는 함수이다.
- 이벤트를 기다리는 무한 루프로서, 이벤트가 들어오면 연결된 사용자정의 함수를 호출한다.
- mlx_ptr: 연결 식별자

```c
int    mlx_key_hook ( void *win_ptr, int (*funct_ptr)(), void *param );

int    mlx_mouse_hook ( void *win_ptr, int (*funct_ptr)(), void *param );

int    mlx_expose_hook ( void *win_ptr, int (*funct_ptr)(), void *param );
```

- 위의 세 함수들은 **mlx_loop**와 완전히 동일하게 작동하는 함수이다.
- 각각 키를 눌렀을 때, 마우스를 클릭했을 때, 창의 일부를 다시 그려야할 때(MacOS는 해당 X) 사용된다.
  - funct_ptr: 이벤트가 일어나면 호출할 함수의 포인터
  - win_ptr: 창 식별자
  - param: 함수가 호출될 때마다 주소가 함수로 전달된다. 함수가 필요로할 수 있는 매개변수를 저장하는데 필요하다.

### 2. mlx_loop_hook() - 이벤트 받기(이벤트가 일어나지 않을 때 함수 호출)

```c
int    mlx_loop_hook ( void *mlx_ptr, int (*funct_ptr)(), void *param );
```

- **mlx_loop_hook**도 mlx_loop와 같이 이벤트를 받는 함수이다.
- 다만, 이벤트가 일어나지 않을 때 매개변수로 받았던 함수를 호출한다.

## 이미지 조작하기

### 1. mlx_new_image() - 새 이미지를 메모리에 생성

```c
void    *mlx_new_image ( void *mlx_ptr, int width, int height );
```

- 새 이미지를 메모리에 생성시킨다.
- mlx_ptr: 연결 식별자
- width, height: 이미지 사이즈(너비, 높이)
- 리턴값: **실패 시 NULL** 리턴, **성공 시 void \*인 이미지 식별자 리턴**

### 2. mlx_put_image_to_window() - 이미지를 창에 표시하기

```c
int    mlx_put_image_to_window ( void *mlx_ptr, void *win_ptr, void *img_ptr, int x, int y );
```

- 사용자는 이미지 내부를 그릴 수 있고 언제든지 지정된 창 내에서 이미지를 덤프해 화면에 표시할 수 있다.
- mlx_ptr: 연결 식별자
- win_ptr: 창 식별자
- img_ptr: 이미지 식별자
- x, y: 창에서 이미지를 배치할 좌표(x,y)

### 3. mlx_get_data_addr() - 생성된 이미지에 대한 정보 리턴

```c
char    *mlx_get_data_addr ( void *img_ptr, int *bits_per_pixel, int *size_line, int *endian );
```

- 생성된 이미지에 대한 정보를 리턴해서 사용자가 나중에 이미지를 수정할 수 있게 하는 함수이다.
- img_ptr: 사용할 이미지 지정
- 다음 세 개의 매개 변수는 세 개의 다른 유효한 정수의 주소(int \*)여야 한다.
  - bits_per_pixel: 픽셀 색상을 나타내는 데 필요한 비트 수
  - size_line: 이미지의 한 줄을 메모리에 저장하는 데 사용되는 바이트 수. 이 정보는 이미지에서 한 줄에서 다른 줄로 이동하는데 필요하다.
  - endian: 이미지의 픽셀 색상을 little endian(endian == 0) 으로 저장할지 big endian(endan == 1)으로 저장할지 알려준다. (MacOS에서는 클라이언트와 그래픽 프레임워크가 동일한 endian을 가지므로 필요 없다.)
- 리턴값: 이미지가 저장된 메모리 영역의 시작을 나타내는 char \*를 리턴한다.
  - 1. 이 주소로부터, 첫 번째 bits_per_pixel 비트가 이미지의 제일 첫 줄의 첫 번째 픽셀의 색상을 나타낸다.
  - 2. 두번째 그룹의 bits_per_pixel 비트는 첫 줄의 두번째 픽셀을 나타내고 그런식으로 쭉 나간다.
  - 3. 주소에 size_line을 추가해서 두 번째 줄 시작점을 얻는다.
  - 이런 방식으로 이미지의 모든 픽셀에 도달할 수 있다.

> Big Endian vs Little Endian?
>
> - big endian: 앞 주소에 큰 바이트부터 기록. 사람 생각과 비슷하다.
> - little endian: 앞 주소에 작은 바이트부터 기록. 인텔 계열의 디폴트.

### 4. mlx_destroy_image() - 이미지 삭제

```c
int    mlx_destroy_image ( void *mlx_ptr, void *img_ptr );
```

- 주어진 이미지(img_ptr)를 삭제하는 함수.

## 창에 그리기

### 1. mlx_pixel_put() - 픽셀 그리기

```c
int    mlx_pixel_put ( void *mlx_ptr, void *win_ptr, int x, int y, int color );
```

- 지정된 창에 픽셀을 그리는 함수.
  - mlx_ptr: 연결 식별자
  - win_ptr: 창 식별자
  - x, y: 픽셀을 표시할 좌표(x,y). (0,0)은 가장 왼쪽 위이고, x값과 y값에 따라 오른쪽 아래로 향한다.
  - color: 픽셀의 색상 지정

### 2. mlx_string_put() - 스트링 표시하기

```c
int    mlx_string_put ( void *mlx_ptr, void *win_ptr, int x, int y, int color, char *string );
```

- 지정된 창에 픽셀 대신 스트링을 표시하는 함수. 다른 파라미터들은 mlx_pixel_put() 함수와 동일하다.
  - string: 표시할 스트링

> 색상 조절하기
> color 매개변수는 int 타입이다. 모든 표시될 수 있는 색상들은 R(Red),G(Green),B(Blue) 3가지 색상으로 이루어져 있다. 이 3가지 색상은 또 0-255 범위로, 각각 얼마만큼 섞였는지를 나타낼 수 있다. 이 3가지 값들이 아래와 같이 int 4바이트에 모두 들어가야 한다.
>
> | 0 | R | G | B | color integer
> +---+---+---+---+

##

## MiniLibX 컴파일하기

MiniLibX 함수들을 사용하기 위해서는, 소프트웨어와 MiniLibX를 포함한 여러 라이브러리들을 링크해주어야 한다.

MacOS 에서는, dynamic Metal library가 `-lmlx` 태그로 스스로 빠진 요소들을 찾아준다.

```
-lmlx
```

그리고 MacOS에서는 static OpenGL version이 아래의 태그를 필요로 한다.

```
-lmlx -framework OpenGL -framework AppKit -lz
```

또한,

```
-L
```

플래그를 이용해 이 라이브러리들에 대한 path를 명시해주어야 한다. 아래의 간단한 실습에서 사용해 볼 것이다.

> OpenGL?  
> 오픈 그래픽 라이브러리는 1992년 실리콘 그래픽스사에서 만든 2차원 및 3차원 그래픽스 표준 API 규격으로, 프로그래밍 언어 간 플랫폼 간의 교차 응용 프로그래밍을 지원한다.

> AppKit?  
> 일반적으로 AppKit이라고 하는 Application Kit는 NeXTSTEP의 그래픽 사용자 인터페이스 툴킷이다. Foundation 및 Display PostScript 와 함께 OpenStep API 사양의 핵심 부분 중 하나입니다. MacOS와 함께 번들로 제공되는 대부분의 응용 프로그램 (예 : Finder , TextEdit , Calendar 및 Preview)은 AppKit을 사용하여 사용자 인터페이스를 제공한다.

# 간단한 실습: MiniLibX를 이용해 창을 띄우고, 색상을 채우고, ESC로 종료시키기

1. 인트라 프로젝트 페이지에서 `minilibx_opengl.tgz`와 `minilibx_mms_20200219_beta.tgz`를 다운받아 압축을 푼다.
2. 두 폴더에 들어가서 make 해서 라이브러리 파일(.dylib, .a)을 만든다.
3. /usr/local/include/에 헤더(.h)를 복사한다.

```
cp minilibx_mms_20200219/*.h /usr/local/include/
cp minilibx_opengl_20191021/*.h /usr/local/include/
```

4. /usr/local/lib/에 라이브러리 파일을 복사한다.

```
cp minilibx_mms_20200219/libmlx.dylib /usr/local/lib/
cp minilibx_opengl_20191021/libmlx.a /usr/local/lib/
```

5. 아래와 같이 main.c를 작성한다.

```c
#include "mlx.h"

int	main()
{
	void	*mlx_ptr;
	void	*win_ptr;

	mlx_ptr = mlx_init();
	win_ptr = mlx_new_window(mlx_ptr, 500, 500, "띄울_창_타이틀");
	mlx_loop(mlx_ptr);
}
```

- mlx_init() 함수와 mlx_new_window() 함수는 모두 void \*를 리턴하는 함수이다. 따라서 void \* 변수를 선언해 받아준다.
- `void *mlx_init();`  
  소프트웨어와 디스플레이 간의 연결을 초기화한다. 가장 먼저 사용해줘야 하는 함수.
- `void *mlx_new_window ( void *mlx_ptr, int size_x, int size_y, char *title );`  
  새 창을 띄운다. 매개변수로 연결 식별자와 창 사이즈, 창 타이틀을 받는다.
- `int mlx_loop ( void *mlx_ptr );`  
  이벤트를 받는 함수이지만 이 경우에서는 창 생성되자마자 바로 프로그램이 종료되지 않도록 무한 루프 해주기 위한 것이다.

6. 컴파일해준 후 실행한다.

```
cc -I /usr/local/include/ main.c -L /usr/local/lib/ -lmlx -framework OpenGL -framework AppKit
```

혹은 그냥 `cc -lmlx main.c`만 해주어도 된다고 한다.

```
./a.out
```

![창 띄우기](/assets/images/new_window.png)

이렇게 창이 뜨면 성공이다.

7. 픽셀을 채우는 코드를 추가한다.

```c
#include "mlx.h"

int	main()
{
	void	*mlx_ptr;
	void	*win_ptr;

	mlx_ptr = mlx_init();
	win_ptr = mlx_new_window(mlx_ptr, 500, 500, "띄울_창_타이틀");
	mlx_pixel_put(mlx_ptr, win_ptr, 250, 250, 0xFFFFFF);
	mlx_loop(mlx_ptr);
}
```

8. ESC 종료 코드를 추가한다.

```c
#include "mlx.h"

int	press_esc_key(int key, void *param)
{
	if (key == 53 && param)
	{
		write(1, "The Window is stopped.\n", 23);
		exit(0);
	}

	return (0);
}

int main()
{
	void	*mlx_ptr;
	void	*win_ptr;

	mlx_ptr = mlx_init();
	win_ptr = mlx_new_window(mlx_ptr, 500, 500, "Nice to meet you");
	mlx_key_hook(win_ptr, press_esc_key, win_ptr);
	mlx_loop(mlx_ptr);
}
```

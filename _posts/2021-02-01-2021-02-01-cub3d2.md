---
layout: single
title: "[cub3D] MiniLibX에 대해 알아보자 + 간단한 실습"
categories: "cub3D"
tags: [cub3D, C]
---

42에서 제공하는 MiniLibX는 간단한 윈도우 인터페이스 라이브러리이다.  
인트라의 cub3D 프로젝트 페이지에서 압축파일을 2개 다 다운받을 수 있다.

```
man minilibx_mms_20200219/man/man3/파일이름
```

매뉴얼에 나와있는 함수들을 하나씩 살펴보자.
나는 맥OS로 진행하므로 맥OS 기준으로 작성할 것이다.

# MiniLibX 함수들

## 시작하기

### 1. mlx_init() - 소프트웨어와 디스플레이 연결

```c
 #include <mlx.h>

void    *mlx_init ();
```

MiniLibX로 쉽게 그래픽 소프트웨어를 만들 수 있다. 유닉스/리눅스 체제 하에서 Window/X11 프로그래밍에 대한 지식이나 맥OS에서 AppKit 프로그래밍에 대한 지식 없이도 가능하다. MiniLibX는 간단한 윈도우 생성, 그리기 도구, 이미지 그리고 기본적인 이벤트 관리를 제공한다.

MacOS: 윈도우 서버와 GPU  
소프트웨어는 윈도우 서버와 직접적으로 상호작용한다. 윈도우 서버는 화면 상에서 다른 소프트웨어나 이벤트 시스템과의 공동 생활을 핸들링한다.
소프트웨어는 또 GPU와도 상호작용하여 모든 그리기 도구들을 핸들링하게 된다.

- 가장 먼저, **소프트웨어와 디스플레이 간에 연결을 초기화** 해주어야 한다.
- 연결을 먼저 한 후에 다른 MiniLibX 함수들을 사용해 디스플레이에 메시지를 전송하거나 전송받을 수 있다.  
  예) "이 창(윈도우)에 노란색 픽셀을 그리고 싶어", "유저가 키를 입력했니?"와 같은 메시지들..
- **mlx_init**이 바로 이 연결을 생성하는 함수이다.
- 리턴값: 디스플레이와의 연결 설정에 **실패 시 NULL** 리턴, **성공 시 non-null 포인터**가 **연결 식별자(connection identifier)**로서 리턴된다.

## 창 관리하기

### 1. mlx_new_window() - 새 창을 스크린에 띄우기

```c
void    *mlx_new_window ( void *mlx_ptr, int size_x, int size_y, char *title );
```

- 새 창을 스크린에 띄우는 함수
- size_x, size_y: 창 사이즈(x길이, y길이)
- title: 띄울 창의 타이틀 (창의 타이틀 바에 표시된다)
- mlx_ptr: mlx_init이 반환한 연결 식별자(connection identifier)
- 리턴값: 창 생성 **실패 시 NULL** 리턴, 성공 시 **void \*인 창 식별자** 리턴.

### 2. mlx_clear_window() - 지정된 창을 검은색으로 지우기

```c
int    mlx_clear_window ( void *mlx_ptr, void *win_ptr );
```

- 지정된 창을 검은색으로 지우는 함수
- mlx_ptr: 연결 식별자
- win_ptr: 창 식별자

### 3. mlx_destroy_window() - 지정된 창 종료하기

```c
int    mlx_destroy_window ( void *mlx_ptr, void *win_ptr );
```

- 지정된 창을 종료하는 함수
- mlx_ptr: 연결 식별자
- win_ptr: 창 식별자

## 이벤트 관리하기

### 1. mlx_loop() - 이벤트 받기

```c
int    mlx_loop ( void *mlx_ptr );
```

### 2. mlx_loop_hook() -

## 이미지 관리하기

### 1. mlx_new_image() - 새 이미지를 메모리에 생성

```c
void    *mlx_new_image ( void *mlx_ptr, int width, int height );
```

- 새 이미지를 메모리에 생성시킨다.
- mlx_ptr: 연결 식별자
- width, height: 이미지 사이즈(너비, 높이)
- 리턴값: **실패 시 NULL** 리턴, **성공 시 void \*인 이미지 식별자 리턴**

### 2. mlx_put_image_to_window() - 이미지를 창에 표시하기

```c
int    mlx_put_image_to_window ( void *mlx_ptr, void *win_ptr, void *img_ptr, int x, int y );
```

- mlx_ptr: 연결 식별자
- win_ptr: 창 식별자
- img_ptr: 이미지 식별자
- x, y: 창에서 이미지를 배치할 좌표(x,y)
- 리턴값:

### 3. mlx_get_data_addr() - 생성된 이미지에 대한 정보 리턴

```c
char    *mlx_get_data_addr ( void *img_ptr, int *bits_per_pixel, int *size_line, int *endian );
```

- 생성된 이미지에 대한 정보를 리턴해서 사용자가 나중에 이미지를 수정할 수 있게 하는 함수이다.
- img_ptr: 사용할 이미지 지정
- 다음 세 개의 매개 변수는 세 개의 다른 유효한 정수의 주소(int \*)여야 한다.
  - bits_per_pixel: 픽셀 색상을 나타내는 데 필요한 비트 수
  - size_line: 이미지의 한 줄을 메모리에 저장하는 데 사용되는 바이트 수. 이 정보는 이미지에서 한 줄에서 다른 줄로 이동하는데 필요하다.
  - endian: 이미지의 픽셀 색상을 little endian(endian == 0) 으로 저장할지 big endian(endan == 1)으로 저장할지 알려준다. (MacOS에서는 클라이언트와 그래픽 프레임워크가 동일한 endian을 가지므로 필요 없다.)
- 리턴값:

> Big Endian vs Little Endian?
>
> - big endian: 앞 주소에 큰 바이트부터 기록. 사람 생각과 비슷하다.
> - little endian: 앞 주소에 작은 바이트부터 기록. 인텔 계열의 디폴트.

## MiniLibX 컴파일하기

MiniLibX 함수들을 사용하기 위해서는, 소프트웨어와 MiniLibX를 포함한 여러 라이브러리들을 링크해주어야 한다.

MacOS 에서는, dynamic Metal library가 `-lmlx` 태그로 스스로 빠진 요소들을 찾아준다.

```
-lmlx
```

그리고 MacOS에서는 static OpenGL version이 아래의 태그를 필요로 한다.

```
-lmlx -framework OpenGL -framework AppKit -lz
```

또한,

```
-L
```

플래그를 이용해 이 라이브러리들에 대한 path를 명시해주어야 한다. 아래의 간단한 실습에서 사용해 볼 것이다.

> OpenGL?  
> 오픈 그래픽 라이브러리는 1992년 실리콘 그래픽스사에서 만든 2차원 및 3차원 그래픽스 표준 API 규격으로, 프로그래밍 언어 간 플랫폼 간의 교차 응용 프로그래밍을 지원한다.

> AppKit?  
> 일반적으로 AppKit이라고 하는 Application Kit는 NeXTSTEP의 그래픽 사용자 인터페이스 툴킷이다. Foundation 및 Display PostScript 와 함께 OpenStep API 사양의 핵심 부분 중 하나입니다. MacOS와 함께 번들로 제공되는 대부분의 응용 프로그램 (예 : Finder , TextEdit , Calendar 및 Preview)은 AppKit을 사용하여 사용자 인터페이스를 제공한다.

# 간단한 실습: MiniLibX를 이용해 창 띄우기

1. 인트라 프로젝트 페이지에서 `minilibx_opengl.tgz`와 `minilibx_mms_20200219_beta.tgz`를 다운받아 압축을 푼다.
2. 두 폴더에 들어가서 make 해서 라이브러리 파일(.dylib, .a)을 만든다.
3. /usr/local/include/에 헤더(.h)를 복사한다.

```
cp minilibx_mms_20200219/*.h /usr/local/include/
cp minilibx_opengl_20191021/*.h /usr/local/include/
```

4. /usr/local/lib/에 라이브러리 파일을 복사한다.

```
cp minilibx_mms_20200219/libmlx.dylib /usr/local/lib/
cp minilibx_opengl_20191021/libmlx.a /usr/local/lib/
```

5. 아래와 같이 main.c를 작성한다.

```c
#include "mlx.h"

int	main()
{
	void	*mlx_ptr;
	void	*win_ptr;

	mlx_ptr = mlx_init();
	win_ptr = mlx_new_window(mlx_ptr, 500, 500, "띄울_창_타이틀");
	mlx_loop(mlx_ptr);
}
```

- mlx_init() 함수와 mlx_new_window() 함수는 모두 void \*를 리턴하는 함수이다. 따라서 void \* 변수를 선언해 받아준다.
- `void *mlx_init();`  
  소프트웨어와 디스플레이 간의 연결을 초기화한다. 가장 먼저 사용해줘야 하는 함수.
- `void *mlx_new_window ( void *mlx_ptr, int size_x, int size_y, char *title );`  
  새 창을 띄운다. 매개변수로 연결 식별자와 창 사이즈, 창 타이틀을 받는다.
- `int mlx_loop ( void *mlx_ptr );`  
  이벤트를 받는 함수이지만 이 경우에서는 창이 바로 종료되지 않도록 loop 해주기 위한 것이다.

6. 컴파일해준 후 실행한다.

```
cc -I /usr/local/include/ main.c -L /usr/local/lib/ -lmlx -framework OpenGL -framework AppKit
```

혹은 그냥 `cc -lmlx main.c`만 해주어도 된다고 한다.

```
./a.out
```

![창 띄우기](/assets/images/new_window.png)

이렇게 창이 뜨면 성공이다.
